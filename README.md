# JConsoleApplication
> 基于Java8，开发控制台应用的轻量级的框架，简化控制台应用的开发过程。
>
> 框架的核心功能是根据字符串格式的命令执行对应的java方法，命令名称即是方法名称，命令参数即是方法参数。
>
> 以此为基础扩展出其他实用的功能，例如应用事件监听器，命令执行条件、自定义类型解析，可选参数和参数默认值等。
>
> 另外框架提供了一个快速开始应用的静态工厂方法，进行少量的配置就能启动应用。

- 注解式开发，使用通过标记注解实现对应的功能



## 相关技术

`Java8`、`maven`、注解、反射

几乎不使用第三方库，所以框架体量非常小，所有功能都由代码实现，仅有的两个依赖其中一个是单元测试，只在演示应用启动时使用，另外一个是`lombok`插件，后续可能会移除这个依赖。



## 基本功能

> 像调用liunx命令一样调用java方法

### 命令的语法

先说一下主要的语法

- **基本命令语法:** 一条命令主要由**命令名**和**命令参数**构成，例如`add 12 13`，这一条命令中`add`是命令名，对应一个名为add的方法，`12`和`13`是命令参数，也对应add方法的参数，当方法没有参数时，命令也不需要参数。

- **可选参数功能:**  当一个方法有多个参数，但是这些参数并不都是必要的，可以通过框架的`@Opt`注解实现可选参数功能，例如：

  ```java
  @Cmd
  public void get(@Opt('a') boolean a, @Opt('b') boolean b, @Opt('c') boolean c) {}
  ```

  对于`@Opt`注解的其他用法后面会提到，就这样的一个方法，每个方法参数上都有这个注解，并且有一个字符来标识这个参数，这样我们可以这样调用这个方法

  `get -a true -b true -c true`

  这条命令中，有三组参数项，第一组是`-a true`，其中`-a`是**参数名**，对应方法参数`a`，`true`是**参数的值**，这个值会被解析后映射到方法参数`a`上，后面的以此类推，在方法中可以观察到，abc三个传进来的参数都是`true`了。

  当然，对于布尔值有更简便的写法，如：

  `get -a -b -c`

  还能更简单：

  `get -abc`

  这些可选参数的出现顺序是没有要求的，而且参数属性的方式可以在一条命令中混合出现，例如:

  `get -b -ac`  等于 `get -a true -b -c true`  等于 `get -c -b -a`

  **注意:** 标记了`@Opt`注解后，如果命令中没有对此方法参数设置值，则这个方法参数为默认值。布尔类型为`false`，数值类型为`0`，引用类型为`null`，举例子: 还是上面的方法，如果这个时候输入命令`get -ac`，在方法中观察，则`a`和`c`为`true`，`b`为`false`

- **参数的全称和简称:** 在`@Opt`注解中，可以指定一个属性`fullName` , 比如下面的一个方法：

  ```java
  @Cmd
  public void find(@Opt(value = 's', fullName = "name") String name, @Opt('a') int age) {}
  ```

  这样的一个方法，可以这样调用:

  `find -s jack`  或者 `find --name jack` ， 这两个命令效果相同。

  **注意:** 如果一个方法上的参数都有`@Opt`注解，那么可以按照方法参数的顺序来填充属性，例如上面的方法可以这样调用

  `find jack`  等于在代码中调用 `find("jack", 0)`; `find jack 11` 等于`find("jack", 11)`

## 启动

有两种开始方式，第一种启动后会在控制台等待输入，根据控制台的输入进行处理命令，将结果在控制台输出。另外一种是获取一个解释器对象，由解释器在解析字符串格式的命令。

- 启动控制台应用

  

像调用命令一样调用方法，比如这样的一个方法(方法上增加了`@Cmd`注解)

```java
@Cmd
private void add(int a, int b) {
    System.out.println(a + b);
}
```

使用这样的命令调用

```bash
add 12 13
```

此时控制台会输出`25`，也就是调用这个add方法的结果，其中`12`和`13`做为了add的参数



